def FILE: struct{};
def TIME: const i64;

def snprintf: extern -> i32;
def fwrite: extern -> i32;
def printf: extern -> i32;
def sscanf: extern -> i32;
def iscntrl: extern val -> i8;
def read: extern file char num -> i32;
def write: extern -> i32;
def exit: extern -> i32;
def ioctl: extern -> i32;
def realloc: extern -> *i8;
def malloc: extern -> *i8;
def free: extern -> i32;
def memset: extern -> i32;
def memcpy: extern -> i32;
def memmove: extern -> *i8;
def strlen: extern -> i32;
def strcpy: extern -> i32;
def fopen: extern -> *FILE;
def fclose: extern -> i32;
def getline: extern -> i32;
def strdup: extern -> *i8;
def time: extern -> TIME;
def strstr: extern -> *i8;

def defaultCallback: inline self a b -> i32 { return 0; };

def Editor: struct {
    def Settings: struct {
        def TABSIZE: const 4;
    };

    def Rows: struct {
        def ERow: struct {
            def size: prop i32;
            def chars: prop *u8;
            def hl: prop *u8;
            def rsize: prop i32;
            def render: prop *u8;

            def Highlight: struct {
                def NORMAL: const 0;
                def NUMBER: const 1;

                def toColor: proc hl -> i32 {
                    if (hl == NUMBER) { return 31; };

                    return 37;
                };
            };

            def update: proc self -> i32 {
                def j: var i32;
                def idx: var i32;
                def tabs: var i32;

                j = 0;
                tabs = 0;
                while (*j < *self.size) {
                    if (*(*self.chars)[*j] == '\t') {
                        tabs = *tabs + 1;
                    };
                    j = *j + 1;
                };


                free(*self.render);
                self.render = malloc(*self.size + *tabs * (Editor.Settings.TABSIZE - 1) + 1 );

                idx = 0;
                j = 0;
                while (*j < *self.size) {
                    def char: const *(*self.chars)[*j];

                    if (char == '\t') {
                        (*self.render)[*idx] = ' ';
                        idx = *idx + 1;
                        while (*idx % Editor.Settings.TABSIZE != 0) {
                            (*self.render)[*idx] = ' ';
                            idx = *idx + 1;
                        };
                    } else {
                        (*self.render)[*idx] = char;
                        idx = *idx + 1;
                    };
                    j = *j + 1;
                };

                (*self.render)[*idx] = 0;
                self.rsize = *idx;

                updateSyntax(self);

                return 0;
            };

            def updateSyntax: proc self -> i32 {
                self.hl = realloc(*self.hl, *self.rsize);
                memset(*self.hl, Highlight.NORMAL, *self.rsize);

                def i: var i32;
                i = 0;
                while (*i < *self.rsize) {
                    def char: const *(*self.render + *i);
                    if (char < '9' + 1 & char > '0' - 1) {
                        (*self.hl + *i) = Highlight.NUMBER;
                    };

                    i = *i + 1;
                };

                return 0;
            };

            def insert: proc self aidx c -> i32 {
                def idx: var i32;
                idx = aidx;

                if (*idx < 0 | *idx > *self.size) {
                    idx = *self.size;
                };
                self.chars = realloc(*self.chars, *self.size + 2);
                memmove((*self.chars) + (*idx + 1), (*self.chars) + *idx, *self.size - *idx + 1);
                self.size = *self.size + 1;
                *self.chars + *idx = i8(*c.value);

                update(self);

                return 0;
            };

            def append: proc self s len -> i32 {
                self.chars = realloc(*self.chars, *self.size + len + 1);
                memcpy((*self.chars) + (*self.size), s, len);
                self.size = *self.size + len;
                *self.chars + *self.size = 0;

                update(self);

                return 0;
            };

            def delete: proc self idx -> i32 {
                if (idx < 0 | idx > *self.size - 1) {
                    return 0;
                };
                memmove((*self.chars) + (idx), (*self.chars) + (idx + 1), *self.size - idx);
                self.size = *self.size - 1;

                update(self);

                return 0;
            };

            def deinit: proc self -> i32 {
                free(*self.render);
                free(*self.chars);
                free(*self.hl);

                return 0;
            };
        };

        def numrows: prop u32;
        def row: prop *ERow;

        def getRow: proc self idx -> *ERow {
            if (idx < *self.numrows) {
                return (*self.row) + (idx * ERow.SIZE);
            };

            return null;
        };

        def deleteRow: proc self at -> i32 {
            if (at < 0 | at > *self.numrows - 1) {
                return 0;
            };
            ERow.deinit(getRow(self, at));
            printf("%p %p %d", getRow(self, at + 1), getRow(self, at), ERow.SIZE * ((*self.numrows) - at - 1));

            memmove(getRow(self, at), getRow(self, at + 1), ERow.SIZE * ((*self.numrows) - at - 1));
            self.numrows = *self.numrows - 1;

            return 0;
        };

        def toString: proc self buflen -> *u8 {
            def totlen: var i32;
            def j: var i32;

            totlen = 0;
            j = 0;

            while (*j < *self.numrows) {
                totlen = *totlen + *getRow(self, *j).size + 1;

                j = *j + 1;
            };

            buflen = *totlen;

            def buf: var *u8;
            def p: var *u8;
            buf = malloc(*totlen);
            p = *buf;

            j = 0;

            while (*j < *self.numrows) {
                def row: const getRow(self, *j);

                memcpy(*p, *row.chars, *row.size);
                p = (*p) + *row.size;
                (*p) = '\n';
                p = (*p) + u32(1);

                j = *j + 1;
            };

            return *buf;
        };

        def insertRow: proc self idx line len -> i32 {
            if (idx < 0 | idx > *self.numrows) {
                return 0;
            };

            self.row = realloc(*self.row, ERow.SIZE * (*self.numrows + 1));

            self.numrows = *self.numrows + 1;

            memmove(Editor.Rows.getRow(self, idx + 1), Editor.Rows.getRow(self, idx), i32(ERow.SIZE * (*self.numrows - idx - 1)));

            def current: const Editor.Rows.getRow(self, idx);

            current.size = len;
            current.chars = malloc(len + 1);
            memcpy(*current.chars, line, len);
            (*current.chars)[len] = 0;

            current.rsize = 0;
            current.render = null;
            current.hl = null;
            Editor.Rows.ERow.update(current);

            return 0;
        };

        def cxToRx: proc row cx -> i32 {
            def rx: var i32;
            def j: var i32;
            rx = 0;
            j = 0;

            while (*j < cx) {
                if (*(*row.chars)[*j] == '\t') {
                    rx = *rx + (Editor.Settings.TABSIZE - 1) - (*rx % Editor.Settings.TABSIZE);
                };
                rx = *rx + 1;
                j = *j + 1;
            };

            return *rx;
        };

        def rxToCx: proc row rx -> i32 {
            def currx: var i32;
            def cx: var i32;

            currx = 0;
            cx = 0;
            while (*cx < *row.size) {
                if (*(*row.chars + *cx) == '\t') {
                    currx = *currx + (Editor.Settings.TABSIZE - 1) - (*currx % Editor.Settings.TABSIZE);
                };
                currx = *currx + 1;

                if (*currx > rx) {
                   return *cx;
                };

                cx = *cx + 1;
            };

            return *cx;
        };
    };

    def rows: prop u32;
    def cols: prop u32;

    def cx: prop u32;
    def cy: prop u32;

    def rx: prop u32;

    def rowoff: prop u32;
    def coloff: prop u32;
    def row: prop Rows;

    def dirty: prop u1;

    def Terminal: struct {
        def termios: struct {
            def iflag: prop u32;
            def oflag: prop u32;
            def cflag: prop u32;
            def lflag: prop u32;
            def cc: prop u8[32];
        };

        def winsize: struct {
            def row: prop u16;
            def col: prop u16;
            def xpixel: prop u16;
            def ypixel: prop u16;
        };

        def getSize: proc x y -> i32 {
            def ws: var winsize;

            ioctl(0, 21523, ws);
            x = 0;
            y = 0;

            x = *ws.row;
            y = *ws.col;

            return 0;
        };

        def startTermios: var termios;

        def tcgetattr: extern file addr -> i32;
        def tcsetattr: extern mode file addr -> i32;

        def enableRawMode: proc -> i32 {
            tcgetattr(0, startTermios);

            def raw: var termios;
            raw = *startTermios;

            raw.iflag = *raw.iflag & ~(2 | 256 | 16 | 32 | 1024);
            raw.oflag = *raw.oflag & ~(1);
            raw.cflag = *raw.cflag | (48);
            raw.lflag = *raw.lflag & ~(8 | 2 | 32768 | 1);

            raw.cc[6] = i8(0);
            raw.cc[5] = i8(1);

            //def i: var i32;
            //i = 0;
            //while (*i < 32) {
            //    printf("%d\r\n", *(raw.cc[*i]));

            //    i = *i + 1;
            //};

            tcsetattr(0, 2, raw);

            return 0;
        };

        def disableRawMode: proc -> i32 {
            tcsetattr(0, 2, startTermios);

            return 0;
        };

        def die: proc -> i32 {
            write(1, "\e[2J", 4);
            write(1, "\e[H", 3);

            perror(s);
            exit(s);

            return 0;
        };
    };

    def Input: struct {
        def Key: struct {
            def value: prop u32;

            def BACKSPACE: const 127;

            def ARROWUP: const 1000;
            def ARROWDOWN: const 1001;
            def ARROWLEFT: const 1002;
            def ARROWRIGHT: const 1003;
            def PAGEUP: const 1004;
            def PAGEDOWN: const 1005;
            def DELETE: const 1006;

            def CTRL: inline key -> i32 {
                return key & 31;
            };
        };

        def readKey: proc -> Key {
            def c: var Key;

            c.value = 0;

            while (read(0, c.value, 1) != 1) {};

            if (*c.value == '\e') {
                def seq: var u8[3];
                seq = null;

                if (read(0, seq[0], 1) != 1) {
                   return *c;
                };
                if (read(0, seq[1], 1) != 1) {
                   return *c;
                };

                printf("%c", *seq[0]);
                printf("%c", *seq[1]);

                if (*seq[0] == '[') {
                    if ((*seq[1] > ('0' - 1)) & (*seq[1] < ('9' + 1))) {
                        read(0, seq[2], 1);
                        printf("%c", *seq[2]);
                        if (*seq[2] == '~') {
                            if (*seq[1] == '3') { c.value = Key.DELETE; };
                            if (*seq[1] == '5') { c.value = Key.PAGEUP; };
                            if (*seq[1] == '6') { c.value = Key.PAGEDOWN; };
                        };
                    } else {
                        if (*seq[1] == 'A') { c.value = Key.ARROWUP; };
                        if (*seq[1] == 'B') { c.value = Key.ARROWDOWN; };
                        if (*seq[1] == 'C') { c.value = Key.ARROWLEFT; };
                        if (*seq[1] == 'D') { c.value = Key.ARROWRIGHT; };
                        if (*seq[1] == 'P') { c.value = Key.DELETE; };
                    };
                };

                printf("\r\n", *seq[1]);
            };

            return *c;
        };

        def processKey: proc self -> i32 {
            def c: var Key;

            c = Input.readKey();

            if (*c.value == Key.CTRL('q')) {
                write(1, "\e[2J", 4);
                write(1, "\e[H", 3);

                exit(0);
            };

            def processed: var u1;
            processed = 0;

            processed = *processed | moveCursor(self, c);

            if (*c.value == Key.CTRL('s')) {
                Editor.File.save(self, *self.statusBar.fileName);

                processed = 1;
            };

            if (*c.value == Key.CTRL('f')) {
                Editor.Search.find(self);

                processed = 1;
            };

            if (*c.value == '\r') {
                insertNewline(self);

                processed = 1;
            };

            if ((*c.value == Key.BACKSPACE) |
                (*c.value == Key.CTRL('h')) |
                (*c.value == Key.DELETE)) {
                if (*c.value == Key.DELETE) {
                    def subKey: var Key;
                    subKey.value = Key.ARROWLEFT;

                    moveCursor(self, subKey);
                };

                scroll(self);

                deleteChar(self);

                processed = 1;
            };

            processed = *processed | u1(iscntrl(*c.value));
            processed = *processed | ((*c.value) > 127);

            if (~(*processed)) {
                insertChar(self, c);
            };

            return 0;
        };

        def scroll: proc self -> u32 {
            self.rx = 0;
            def current: const Editor.Rows.getRow(self.row, *self.cy);
            if (current != null) {
                self.rx = Editor.Rows.cxToRx(current, *self.cx);
            };

            if (*self.cy < *self.rowoff) {
                self.rowoff = *self.cy;
            };
            if (*self.cy + 1 > *self.rowoff + *self.rows) {
                self.rowoff = *self.cy - *self.rows + 1;
            };
            if (*self.rx < *self.coloff) {
                self.coloff = *self.rx;
            };
            if (*self.rx + 1 > *self.coloff + *self.cols) {
                self.coloff = *self.rx - *self.cols + 1;
            };

            return 0;
        };

        def moveCursor: proc self key -> u1 {
            def current: const Editor.Rows.getRow(self.row, *self.cy);
            def result: var u1;

            result = 0;

            if (*key.value == Key.ARROWRIGHT) {
                result = 1;
                if (*self.cx != 0) {
                   self.cx = *self.cx - 1;
                } else {
                    if (*self.cy > 0) {
                        self.cy = *self.cy - 1;
                        self.cx = *Editor.Rows.getRow(self.row, *self.cy).size;
                    };
                };
            };
            if (*key.value == Key.ARROWLEFT) {
                result = 1;
                if (current != null) {
                    if (*self.cx < *current.size) {
                        self.cx = *self.cx + 1;
                    } else {
                        self.cy = *self.cy + 1;
                        self.cx = 0;
                    };
                };
            };
            if (*key.value == Key.ARROWUP) {
                result = 1;
                if (*self.cy != 0) {
                    self.cy = *self.cy - 1;
                };
            };
            if (*key.value == Key.ARROWDOWN) {
                result = 1;
                if (*self.cy != *self.row.numrows - 1 & *self.row.numrows != 0) {
                    self.cy = *self.cy + 1;
                };
            };

            if (*key.value == Key.PAGEUP | *key.value == Key.PAGEDOWN) {
                result = 1;
                def idx: var i16;
                def subKey: var Key;
                idx = *self.rows;

                if (*key.value == Key.PAGEUP) {
                    self.cy = *self.rowoff;
                } else {
                    self.cy = *self.rowoff + *self.rows - 1;
                    if (*self.cy > *self.row.numrows) {
                        self.cy = *self.row.numrows;
                    };
                };

                subKey.value = Key.ARROWUP;
                if (*key.value == Key.PAGEDOWN) {
                    subKey.value = Key.ARROWDOWN;
                };

                while (*idx != 0) {
                    moveCursor(self, subKey);
                    idx = *idx - 1;
                };
            };

            def current: const Editor.Rows.getRow(self.row, *self.cy);
            def len: var i32;
            len = 0;
            if (current != null) {
                len = *current.size;
            };
            if (*self.cx > *len) {
                self.cx = *len;
            };

            return *result;
        };

        def insertChar: proc self c -> i32 {
            if (*self.cy == *self.row.numrows) {
                Editor.Rows.insertRow(self.row, *self.row.numrows, "", 0);
            };

            Editor.Rows.ERow.insert(
                Editor.Rows.getRow(self.row, *self.cy),
                *self.cx,
                c
            );

            self.cx = *self.cx + 1;
            self.dirty = 1;

            return 0;
        };

        def insertNewline: proc self -> i32 {
            if (*self.cx == 0) {
                Editor.Rows.insertRow(self.row, *self.cy, "", 0);
            } else {
                def row: const Editor.Rows.getRow(self.row, *self.cy);
                printf("'%.*s'\r\n", *row.size - *self.cx, (*row.chars + *self.cx));

                Editor.Rows.insertRow(self.row, *self.cy + 1, (*row.chars + *self.cx), *row.size - *self.cx);

                def current: const Editor.Rows.getRow(self.row, *self.cy);
                current.size = *self.cx;
                (*current.chars) + (*current.size) = 0;
                Editor.Rows.ERow.update(current);
            };
            self.cy = *self.cy + 1;
            self.cx = 0;

            return 0;
        };

        def deleteChar: proc self -> i32 {
            if (*self.cy == *self.row.numrows) {
                return 0;
            };
            if (*self.cy == 0 & *self.cx == 0) {
                return 0;
            };

            def current: const Editor.Rows.getRow(self.row, *self.cy);
            if (*self.cx > 0) {
                Editor.Rows.ERow.delete(current, (*self.cx) - 1);
                self.cx = *self.cx - 1;
            } else {
                def prev: const Editor.Rows.getRow(self.row, *self.cy - 1);
                self.cx = *prev.size;
                Editor.Rows.ERow.append(prev, *current.chars, *current.size);
                Editor.Rows.deleteRow(self.row, *self.cy);
                self.cy = *self.cy - 1;
            };

            return 0;
        };
    };

    def Display: struct {
        def StatusBar: struct {
            def fileName: prop *u8;
            def msg: prop u8[80];
            def msglen: prop u32;
            def msgTime: prop TIME;

            def showMessage: proc self base msg -> i32 {
                self.msglen = snprintf(self.msg, 80, base, msg);

                self.msgTime = 0;
                self.msgTime = time(0);

                return 0;
            };

            def render: proc self ed buff -> i32 {
                Editor.Display.abuf.append(buff, "\e[7m", 4);
                def status: var u8[80];
                def rstatus: var u8[80];
                def len: var u32;
                def rlen: var u32;

                rlen = snprintf(rstatus, 80, "%d/%d", *ed.cy + 1, *ed.row.numrows);

                def dirty: var *u8;
                dirty = "";
                if (*ed.dirty) {
                   dirty = "(modified)";
                };

                if (*self.fileName == null) {
                    len = snprintf(status, 80, "%.20s - %d lines %s", "[No Name]", *ed.row.numrows, *dirty);
                } else {
                    len = snprintf(status, 80, "%.20s - %d lines %s", *self.fileName, *ed.row.numrows, *dirty);
                };

                if (*len > *ed.cols) {
                    len = *ed.cols;
                };

                Editor.Display.abuf.append(buff, status, *len);

                while (*len < *ed.cols) {
                    if (*ed.cols - *len == *rlen) {
                        Editor.Display.abuf.append(buff, rstatus, *rlen);
                        len = *len + *rlen;
                    } else {
                        Editor.Display.abuf.append(buff, " ", 1);
                        len = *len + 1;
                    };
                };

                Editor.Display.abuf.append(buff, "\e[m\r\n", 5);

                // message bar

                Editor.Display.abuf.append(buff, "\e[K", 3);
                def len: var i32;

                len = *self.msglen;

                if (*len > *ed.cols) {
                    len = *ed.cols;
                };

                if ((*len != 0) & (time(0) - (*self.msgTime) < 5)) {
                   Editor.Display.abuf.append(buff, self.msg, *len);
                };

                return 0;
            };

            def prompt: proc ed msg callback -> *u8 {
                def bufsize: var u32;
                def buflen: var u32;
                def buf: var *u8;

                bufsize = 128;
                buf = malloc(*bufsize);

                *buf = 0;
                buflen = 0;

                while (1) {
                    showMessage(ed.statusBar, msg, *buf);
                    Editor.Display.render(ed);

                    def c: var Editor.Input.Key;
                    c = Editor.Input.readKey();

                    if (*c.value == '\e') {
                        showMessage(ed.statusBar, "%s", "");
                        callback(self, *buf, c);

                        free(*buf);
                        buf = null;
                        return *buf;
                    };

                    if (*c.value == '\r') {
                        if (*buflen != 0) {
                            showMessage(ed.statusBar, "%s", "");
                            callback(self, *buf, c);

                            return *buf;
                        };
                    } else {
                        if (~iscntrl(*c.value) & *c.value < 128) {
                            if (*buflen == *bufsize - 1) {
                                bufsize = *bufsize * 2;
                                buf = realloc(*buf, *bufsize);
                            };
                            (*buf + (*buflen)) = u8(*c.value);
                            buflen = *buflen + 1;
                            (*buf + (*buflen)) = 0;
                        };
                    };

                    callback(self, *buf, c);
                };

                return null;
            };
        };

        def abuf: struct {
            def b: prop *u8;
            def len: prop u32;

            def append: proc self s len -> u32 {
                self.b = realloc(*self.b, *self.len + len);

                memcpy((*self.b)[*self.len], s, len);
                self.len = *self.len + len;

                return 0;
            };

            def deinit: proc self -> u32 {
                free(*self.b);

                return 0;
            };
        };

        def drawRows: proc self buff -> u32 {
            def y: var u32;

            y = 0;

            while (*y < *self.rows) {
                def filerow: const *y + *self.rowoff;

                if (filerow > *self.row.numrows - 1) {
                     abuf.append(buff, "~", 1);
                } else {
                    def len: var i32;
                    def current: const Editor.Rows.getRow(self.row, filerow);
                    if (*current.rsize < *self.coloff) {
                        len = 0;
                    } else {
                        len = *current.rsize - *self.coloff;
                    };

                    if (*len > *self.cols) {
                        len = *self.cols;
                    };

                    def currentColor: var i32;
                    currentColor = 0 - 1;

                    if (*len != 0) {
                        def j: var i32;
                        def c: const (*current.render) + *self.coloff;
                        def hl: const (*current.hl) + *self.coloff;

                        j = 0;
                        while (*j < *len) {
                            if (*(hl + *j) == Editor.Rows.ERow.Highlight.NORMAL) {
                                if (*currentColor != 0 - 1) {
                                    abuf.append(buff, "\e[39m", 5);
                                    currentColor = 0 - 1;
                                };
                                abuf.append(buff, (c + *j), 1);
                            } else {
                                def color: const Editor.Rows.ERow.Highlight.toColor(*(hl + *j));
                                if (*currentColor != color) {
                                    def buf: var i8[16];
                                    def clen: const snprintf(buf, 16, "\e[%dm", color);
                                    abuf.append(buff, buf, clen);
                                    currentColor = color;
                                };
                                abuf.append(buff, (c + *j), 1);
                            };

                            j = *j + 1;
                        };
                        abuf.append(buff, "\e[39m", 5);
                    };
                };

                abuf.append(buff, "\e[K", 3);
                abuf.append(buff, "\r\n", 2);

                y = *y + 1;
            };

            return 0;
        };

        def render: proc self -> u32 {
            Editor.Input.scroll(self);

            def buff: var abuf;

            buff.b = null;
            buff.len = 0;

            abuf.append(buff, "\e[?25l", 6);
            abuf.append(buff, "\e[H", 3);
            Display.drawRows(self, buff);
            Display.StatusBar.render(self.statusBar, self, buff);

            def tmpBuf: var u8[32];

            snprintf(tmpBuf, 32, "\e[%d;%dH", (*self.cy - *self.rowoff) + 1, (*self.rx - *self.coloff) + 1);
            abuf.append(buff, tmpBuf, strlen(tmpBuf));

            abuf.append(buff, "\e[?25h", 6);

            write(1, *buff.b, *buff.len);
            abuf.deinit(buff);

            return 0;
        };
    };

    def statusBar: prop Display.StatusBar;

    def Search: struct {
        def findCB: inline self query key -> i32 {
            def i: var i32;
            i = 0;
            while (*i < *self.row.numrows) {
                def row: const Editor.Rows.getRow(self.row, *i);
                def match: const strstr(*row.render, *query);
                if (match != null) {
                    self.cy = *i;
                    self.cx = Editor.Rows.rxToCx(row, i32(match - *row.render));
                    self.rowoff = *self.row.numrows;
                    i = *self.row.numrows;
                };

                i = *i + 1;
            };

            return 0;
        };

        def find: proc self -> i32 {
            def query: const Editor.Display.StatusBar.prompt(self, "Search: %s (ESC to cancel)", findCB);

            if (query != null) {
                free(query);
            };

            return 0;
        };
    };

    def File: struct {
        def strip: proc line linelen -> i32 {
            while (*(line + (*linelen - 1)) == '\n' |
                   *(line + (*linelen - 1)) == '\r') {
                linelen = *linelen - 1;
                if (*linelen == 0) {
                    return 0;
                };
            };

            return 0;
        };

        def save: proc self afilename -> i32 {
            def filename: var *u8;

            if (afilename == null) {
                filename = Editor.Display.StatusBar.prompt(self, "Save as: %s (ESC to cancel)", defaultCallback);
                if (*filename == null) {
                    Editor.Display.StatusBar.showMessage(self.statusBar, "Save aborted %s", "");
                    return 0;
                };
            } else {
                filename = afilename;
            };

            def len: var i32;
            def buf: var *u8;

            buf = Editor.Rows.toString(self.row, len);
            def fp: var *FILE;

            fp = fopen(*filename, "wb+");
            fwrite(*buf, *len, 1, *fp);
            fclose(*fp);

            Editor.Display.StatusBar.showMessage(self.statusBar, "%d Bytes Written To Disk", *len);

            return 0;
        };

        def open: proc self filename -> i32 {
            free(*self.statusBar.fileName);
            self.statusBar.fileName = strdup(filename);

            def fp: var *FILE;

            fp = fopen(filename, "rb");

            def line: var *u8;
            def linecap: var i32;
            def linelen: var i32;

            line = null;
            linecap = 0;
            linelen = getline(line, linecap, *fp);

            while (*linelen > 0) {
                strip(*line, linelen);

                Editor.Rows.insertRow(self.row, *self.row.numrows, *line, *linelen);

                linelen = getline(line, linecap, *fp);
            };

            free(*line);
            fclose(*fp);

            self.dirty = 0;

            return 0;
        };
    };

    def init: proc -> Editor {
        def result: var Editor;

        Terminal.getSize(result.rows, result.cols);
        result.rows = *result.rows - 2;

        result.cx = 0;
        result.cy = 0;
        result.rx = 0;
        result.dirty = 0;
        result.statusBar.fileName = null;
        result.statusBar.msg[0] = 0;
        result.statusBar.msgTime = 0;
        result.row.numrows = 0;
        result.row.row = null;
        result.rowoff = 0;
        result.coloff = 0;

        return *result;
    };

    def run: proc self -> i32 {
        def c: var u8;
        def count: var i64;

        Terminal.enableRawMode();

        while (1) {
            Display.render(self);
            Input.processKey(self);
        };

        Terminal.disableRawMode();

        return 0;
    };
};

def main: proc argc argv -> i32 {
    def ed: var Editor;

    ed = Editor.init();
    if (argc > 1) {
        Editor.File.open(ed, *(argv[1]));
    };

    Editor.Display.StatusBar.showMessage(ed.statusBar, "%s", "HELP: Ctrl-Q = quit");

    Editor.run(ed);

    return 0;
};
