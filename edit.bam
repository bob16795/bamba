def FILE: struct{};
def TIME: const i64;

def snprintf: extern -> i32;
def fwrite: extern -> i32;
def printf: extern -> i32;
def sscanf: extern -> i32;
def iscntrl: extern val -> i8;
def read: extern file char num -> i32;
def write: extern -> i32;
def exit: extern -> i32;
def ioctl: extern -> i32;
def realloc: extern -> *i8;
def malloc: extern -> *i8;
def free: extern -> i32;
def memset: extern -> i32;
def memcpy: extern -> i32;
def memmove: extern -> *i8;
def strlen: extern -> i32;
def strcpy: extern -> i32;
def strcmp: extern -> i32;
def fopen: extern -> *FILE;
def fclose: extern -> i32;
def getline: extern -> i32;
def strdup: extern -> *i8;
def time: extern -> TIME;
def strstr: extern -> *i8;
def strncmp: extern -> i32;
def strchr: extern -> *i8;
def strrchr: extern -> *i8;
def isspace: extern -> i8;

def defaultCallback: proc self a b -> i32 { return 0; };

def Editor: struct {
    def Settings: struct {
        def TABSIZE: const 2;
        def NUMBERLEN: const 4;
    };

    def Rows: struct {
        def Syntax: struct {
            def Flags: struct {
                def HIGHLIGHTNUMBERS: const 1;
                def HIGHLIGHTSTRINGS: const 2;
            };

            def getFlags: proc ext -> i32 {
                if (strcmp(ext, ".c") == 0) {
                   return Flags.HIGHLIGHTNUMBERS |
                          Flags.HIGHLIGHTSTRINGS;
                };

                if (strcmp(ext, ".bam") == 0) {
                   return Flags.HIGHLIGHTNUMBERS |
                          Flags.HIGHLIGHTSTRINGS;
                };

                return 0;
            };

            def getComment: proc ext -> *u8 {
                if (strcmp(ext, ".c") == 0) { return "//"; };
                if (strcmp(ext, ".bam") == 0) { return "//"; };

                return null;
            };

            def getMLCommentStart: proc ext -> *u8 {
                if (strcmp(ext, ".c") == 0) { return "/*"; };


                return null;
            };
            
            def getMLCommentEnd: proc ext -> *u8 {
                if (strcmp(ext, ".c") == 0) { return "*/"; };

                return null;
            };

            def getName: proc ext -> *u8 {
                if (strcmp(ext, ".c") == 0) { return "C"; };
                if (strcmp(ext, ".bam") == 0) { return "BAMBA"; };

                return null;
            };

            def getKeywords: proc ext -> *(*u8) {
                def result: var *(*u8);
                result = null;

                if (strcmp(ext, ".c") == 0) {
                    result = realloc(*result, (*u8).SIZE * 24);
                    (*result + (*u8).SIZE * 0) = "switch";
                    (*result + (*u8).SIZE * 1) = "if";
                    (*result + (*u8).SIZE * 2) = "while";
                    (*result + (*u8).SIZE * 3) = "for";
                    (*result + (*u8).SIZE * 4) = "break";
                    (*result + (*u8).SIZE * 5) = "continue";
                    (*result + (*u8).SIZE * 6) = "return";
                    (*result + (*u8).SIZE * 7) = "else";
                    (*result + (*u8).SIZE * 8) = "struct";
                    (*result + (*u8).SIZE * 9) = "union";
                    (*result + (*u8).SIZE * 10) = "typedef";
                    (*result + (*u8).SIZE * 11) = "static";
                    (*result + (*u8).SIZE * 12) = "enum";
                    (*result + (*u8).SIZE * 13) = "class";
                    (*result + (*u8).SIZE * 14) = "case";
                    (*result + (*u8).SIZE * 15) = "int|";
                    (*result + (*u8).SIZE * 16) = "long|";
                    (*result + (*u8).SIZE * 17) = "double|";
                    (*result + (*u8).SIZE * 18) = "float|";
                    (*result + (*u8).SIZE * 19) = "char|";
                    (*result + (*u8).SIZE * 20) = "unsigned|";
                    (*result + (*u8).SIZE * 21) = "signed|";
                    (*result + (*u8).SIZE * 22) = "void|";
                    (*result + (*u8).SIZE * 23) = null;
                };
                
                if (strcmp(ext, ".bam") == 0) {
                    result = realloc(*result, (*u8).SIZE * 15);
                    (*result + (*u8).SIZE * 0) = "return";
                    (*result + (*u8).SIZE * 1) = "extern";
                    (*result + (*u8).SIZE * 2) = "struct";
                    (*result + (*u8).SIZE * 3) = "inline";
                    (*result + (*u8).SIZE * 4) = "const";
                    (*result + (*u8).SIZE * 5) = "clone";
                    (*result + (*u8).SIZE * 6) = "while";
                    (*result + (*u8).SIZE * 7) = "proc";
                    (*result + (*u8).SIZE * 8) = "prop";
                    (*result + (*u8).SIZE * 9) = "else";
                    (*result + (*u8).SIZE * 10) = "var";
                    (*result + (*u8).SIZE * 11) = "if";
                    (*result + (*u8).SIZE * 12) = "def|";
                    (*result + (*u8).SIZE * 13) = "->|";
                    (*result + (*u8).SIZE * 14) = null;
                };


                return *result;
            };

            def flags: prop i32;
            def commentStart: prop *u8;
            def mlCommentStart: prop *u8;
            def mlCommentEnd: prop *u8;
            def keywords: prop *(*u8);
            def name: prop *u8;
        };

        def syntax: prop Syntax;

        def selectSyntax: proc self filename -> i32 {
            self.syntax.name = null;
            if (filename == null) { return 0; };

            def ext: const strrchr(filename, '.');

            self.syntax.flags = Syntax.getFlags(ext);
            self.syntax.mlCommentStart = Syntax.getMLCommentStart(ext);
            self.syntax.mlCommentEnd = Syntax.getMLCommentEnd(ext);
            self.syntax.commentStart = Syntax.getComment(ext);
            self.syntax.name = Syntax.getName(ext);
            self.syntax.keywords = Syntax.getKeywords(ext);

            return 0;
        };

        def ERow: struct {
            def idx: prop i32;
            def size: prop i32;
            def chars: prop *u8;
            def hl: prop *u8;
            def rsize: prop i32;
            def render: prop *u8;
            def opencomment: prop u1;

            def Highlight: struct {
                def NORMAL: const 0;
                def COMMENT: const 1;
                def MLCOMMENT: const 2;
                def KEYWORDA: const 3;
                def KEYWORDB: const 4;
                def STRING: const 5;
                def NUMBER: const 6;
                def MATCH: const 7;

                def toColor: proc hl -> i32 {
                    if (hl == COMMENT) { return 36; };
                    if (hl == MLCOMMENT) { return 36; };
                    if (hl == KEYWORDA) { return 33; };
                    if (hl == KEYWORDB) { return 32; };
                    if (hl == STRING) { return 35; };
                    if (hl == NUMBER) { return 31; };
                    if (hl == MATCH) { return 34; };

                    return 37;
                };
            };

            def update: proc rows self syntax -> i32 {
                def j: var i32;
                def idx: var i32;
                def tabs: var i32;

                j = 0;
                tabs = 0;
                while (*j < *self.size) {
                    if (*(*self.chars)[*j] == '\t') {
                        tabs = *tabs + 1;
                    };
                    j = *j + 1;
                };


                free(*self.render);
                self.render = malloc(*self.size + *tabs * (Editor.Settings.TABSIZE - 1) + 1 );

                idx = 0;
                j = 0;
                while (*j < *self.size) {
                    def char: const *(*self.chars)[*j];

                    if (char == '\t') {
                        (*self.render)[*idx] = ' ';
                        idx = *idx + 1;
                        while (*idx % Editor.Settings.TABSIZE != 0) {
                            (*self.render)[*idx] = ' ';
                            idx = *idx + 1;
                        };
                    } else {
                        (*self.render)[*idx] = char;
                        idx = *idx + 1;
                    };
                    j = *j + 1;
                };

                (*self.render)[*idx] = 0;
                self.rsize = *idx;

                updateSyntax(rows, self, syntax);

                return 0;
            };

            def updateSyntax: proc rows self syntax -> i32 {
                def issep: inline ch -> i1 {
                    return ch == ' ' | ch == '\t' | (ch == 0) | (strchr(",.()+-/*=~%<>[];", ch) != null);
                };

                def isdigit: proc ch -> i1 {
                    return ch < '9' + 1 & ch > '0' - 1;
                };

                self.hl = realloc(*self.hl, *self.rsize);
                memset(*self.hl, Highlight.NORMAL, *self.rsize);

                def syntaxFlags: const *syntax.flags;
                def keywords: const *syntax.keywords;

                if (syntaxFlags == 0) {
                    return 0;
                };

                def scs: const *syntax.commentStart;
                def mcs: const *syntax.mlCommentStart;
                def mce: const *syntax.mlCommentEnd;

                def scslen: var i32;
                def mcslen: var i32;
                def mcelen: var i32;

                if (scs != null) { scslen = strlen(scs); } else { scslen = 0; };
                if (mcs != null) { mcslen = strlen(mcs); } else { mcslen = 0; };
                if (mce != null) { mcelen = strlen(mce); } else { mcelen = 0; };

                def prevsep: var i1;
                def instring: var i8;
                def incomment: var i1;

                def i: var i32;

                prevsep = 1;
                instring = 0;
                incomment = 0;
                if (*self.idx > 0) {
                    incomment = *Editor.Rows.getRow(rows, *self.idx - 1).opencomment;
                };

                i = 0;
                while (*i < *self.rsize) {
                    def char: const *(*self.render + *i);
                    def prevhl: var i8;

                    if (*i > 0) {
                        prevhl = *(*self.hl + (*i - 1));
                    } else {
                        prevhl = Highlight.NORMAL;
                    };

                    def processed: var u1;

                    processed = 0;
                    
                    if (~(*processed) & (*mcslen != 0) & (*mcelen != 0) & ~(u1)(*instring)) {
                        if (*incomment) {
                            (*self.hl + *i) = Highlight.MLCOMMENT;
                            if (strncmp(*self.render + *i, mce, *mcelen) == 0) {
                                memset(*self.hl + *i, Highlight.MLCOMMENT, *mcelen);
                                i = *i + *mcelen;
                                incomment = 0;
                                prevsep = 0;
                                processed = 1;
                            } else {
                                i = *i + 1;
                                processed = 1;
                            };
                        } else {
                            if (strncmp(*self.render + *i, mcs, *mcslen) == 0) {
                                memset(*self.hl + *i, Highlight.MLCOMMENT, *mcslen);
                                i = *i + *mcslen;
                                incomment = 1;
                                processed = 1;
                            };
                        };
                    };

                    if (~(*processed) & (scs) != null) {
                        if (strncmp(*self.render + *i, scs, *scslen) == 0) {
                            memset(*self.hl + *i, Highlight.COMMENT, *self.rsize - *i);

                            return 0;
                        };
                    };

                    if (~(*processed) & (syntaxFlags & Editor.Rows.Syntax.Flags.HIGHLIGHTSTRINGS) != 0) {
                        if (*instring != 0) {
                            (*self.hl + *i) = Highlight.STRING;

                            if (char == '\\' & *i + 1 < *self.rsize) {
                                (*self.hl + *i + 1) = Highlight.STRING;
                                i = *i + 2;
                            } else {
                                if (char == *instring) {
                                    instring = 0;
                                };

                                i = *i + 1;
                                prevsep = 1;
                            };
                            processed = 1;
                        } else {
                            if (char == 39 | char == '"') {
                                instring = char;
                                (*self.hl + *i) = Highlight.STRING;
                                i = *i + 1;
                                processed = 1;
                            };
                        };
                    };

                    if (~(*processed) & (syntaxFlags & Editor.Rows.Syntax.Flags.HIGHLIGHTNUMBERS) != 0) {
                        if ((isdigit(char)) &
                            (*prevsep | *prevhl == Highlight.NUMBER) |
                            (char == '.' & *prevhl == Highlight.NUMBER)) {
                            (*self.hl + *i) = Highlight.NUMBER;
                            i = *i + 1;
                            prevsep = 0;
                            processed = 1;
                        };
                    };

                    if (~(*processed) & *prevsep & keywords != null) {
                        def oldi: const *i;

                        def j: var i32;
                        j = 0;
                        while (*i == oldi & *(keywords + (*u8).SIZE * *j) != null) {
                            def word: const *(keywords + (*u8).SIZE * *j);
                            def klen: var i32;
                            klen = strlen(word);
                            def kwb: const *(word + (*klen - 1)) == '|';
                            if (kwb) { klen = *klen - 1; };

                            if (strncmp(*self.render + *i, word, *klen) == 0 &
                                issep(*(*self.render + *i + *klen))) {
                                if (kwb) {
                                    memset(*self.hl + *i, Highlight.KEYWORDB, *klen);
                                } else {
                                    memset(*self.hl + *i, Highlight.KEYWORDA, *klen);
                                };
                                i = *i + *klen;
                                prevsep = 0;
                                processed = 1;
                            };

                            j = *j + 1;
                        };
                    };

                    if (*processed == 0) {
                        prevsep = issep(char);
                        i = *i + 1;
                    };
                };

                def changed: const *self.opencomment != *incomment;       
                self.opencomment = *incomment;
                if (changed & (*self.idx + 1 < *rows.numrows)) {
                    updateSyntax(rows, Editor.Rows.getRow(rows, *self.idx + 1), syntax);
                };

                return 0;
            };

            def insert: proc rows self aidx c syntaxFlags -> i32 {
                def idx: var i32;
                idx = aidx;

                if (*idx < 0 | *idx > *self.size) {
                    idx = *self.size;
                };
                self.chars = realloc(*self.chars, *self.size + 2);
                memmove((*self.chars) + (*idx + 1), (*self.chars) + *idx, *self.size - *idx + 1);
                self.size = *self.size + 1;
                *self.chars + *idx = i8(*c.value);

                update(rows, self, syntaxFlags);

                return 0;
            };

            def append: proc rows self s len syntaxFlags -> i32 {
                self.chars = realloc(*self.chars, *self.size + len + 1);
                memcpy((*self.chars) + (*self.size), s, len);
                self.size = *self.size + len;
                *self.chars + *self.size = 0;

                update(rows, self, syntaxFlags);

                return 0;
            };

            def delete: proc rows self idx syntaxFlags -> i32 {
                if (idx < 0 | idx > *self.size - 1) {
                    return 0;
                };
                memmove((*self.chars) + (idx), (*self.chars) + (idx + 1), *self.size - idx);
                self.size = *self.size - 1;

                update(rows, self, syntaxFlags);

                return 0;
            };

            def deinit: proc self -> i32 {
                free(*self.render);
                free(*self.chars);
                free(*self.hl);

                return 0;
            };
        };

        def numrows: prop u32;
        def row: prop *ERow;

        def getRow: proc self idx -> *ERow {
            if (idx < *self.numrows) {
                return (*self.row) + (idx * ERow.SIZE);
            };

            return null;
        };

        def deleteRow: proc self at -> i32 {
            if (at < 0 | at > *self.numrows - 1) {
                return 0;
            };
            ERow.deinit(getRow(self, at));

            memmove(getRow(self, at), getRow(self, at + 1), ERow.SIZE * ((*self.numrows) - at - 1));
            self.numrows = *self.numrows - 1;

            def j: var i32;
            j = at;
            while (*j < *self.numrows - 1) {
                def row: const Editor.Rows.getRow(self, *j);
                row.idx = *j;
                j = *j + 1;
            };


            return 0;
        };

        def toString: proc self buflen -> *u8 {
            def totlen: var i32;
            def j: var i32;

            totlen = 0;
            j = 0;

            while (*j < *self.numrows) {
                totlen = *totlen + *getRow(self, *j).size + 1;

                j = *j + 1;
            };

            buflen = *totlen;

            def buf: var *u8;
            def p: var *u8;
            buf = malloc(*totlen);
            p = *buf;

            j = 0;

            while (*j < *self.numrows) {
                def row: const getRow(self, *j);

                memcpy(*p, *row.chars, *row.size);
                p = (*p) + *row.size;
                (*p) = '\n';
                p = (*p) + u32(1);

                j = *j + 1;
            };

            return *buf;
        };

        def insertRow: proc self idx line len -> i32 {
            if (idx < 0 | idx > *self.numrows) {
                return 0;
            };

            self.row = realloc(*self.row, ERow.SIZE * (*self.numrows + 1));

            self.numrows = *self.numrows + 1;

            memmove(Editor.Rows.getRow(self, idx + 1), Editor.Rows.getRow(self, idx), i32(ERow.SIZE * (*self.numrows - idx - 1)));

            def j: var i32;
            j = idx;
            while (*j < *self.numrows - 1) {
                def row: const Editor.Rows.getRow(self, *j);
                row.idx = *j;

                j = *j + 1;
            };

            def current: const Editor.Rows.getRow(self, idx);

            current.size = len;
            current.chars = malloc(len + 1);
            memcpy(*current.chars, line, len);
            (*current.chars)[len] = 0;

            current.rsize = 0;
            current.render = null;
            current.hl = null;
            current.idx = idx;
            current.opencomment = 0;
            Editor.Rows.ERow.update(self, current, self.syntax);

            return 0;
        };

        def cxToRx: proc row cx -> i32 {
            def rx: var i32;
            def j: var i32;
            rx = 0;
            j = 0;

            while (*j < cx) {
                if (*(*row.chars)[*j] == '\t') {
                    rx = *rx + (Editor.Settings.TABSIZE - 1) - (*rx % Editor.Settings.TABSIZE);
                };
                rx = *rx + 1;
                j = *j + 1;
            };

            return *rx;
        };

        def rxToCx: proc row rx -> i32 {
            def currx: var i32;
            def cx: var i32;

            currx = 0;
            cx = 0;
            while (*cx < *row.size) {
                if (*(*row.chars + *cx) == '\t') {
                    currx = *currx + (Editor.Settings.TABSIZE - 1) - (*currx % Editor.Settings.TABSIZE);
                };
                currx = *currx + 1;

                if (*currx > rx) {
                   return *cx;
                };

                cx = *cx + 1;
            };

            return *cx;
        };
    };

    def rows: prop u32;
    def cols: prop u32;

    def cx: prop u32;
    def cy: prop u32;

    def rx: prop u32;

    def rowoff: prop u32;
    def coloff: prop u32;
    def row: prop Rows;

    def dirty: prop u1;

    def Terminal: struct {
        def termios: struct {
            def iflag: prop u32;
            def oflag: prop u32;
            def cflag: prop u32;
            def lflag: prop u32;
            def line: prop u8;
            def cc: prop u8[32];
            def ispeed: prop u32;
            def ospeed: prop u32;
        };

        def winsize: struct {
            def row: prop u16;
            def col: prop u16;
            def xpixel: prop u16;
            def ypixel: prop u16;
        };

        def getSize: proc x y -> i32 {
            def ws: var winsize;

            ioctl(0, 21523, ws);
            x = 0;
            y = 0;

            x = *ws.row;
            y = *ws.col;

            return 0;
        };

        def startTermios: var termios;

        def tcgetattr: extern file addr -> i32;
        def tcsetattr: extern mode file addr -> i32;

        def enableRawMode: proc -> i32 {
            tcgetattr(0, startTermios);

            def raw: var termios;
            raw = *startTermios;

            raw.iflag = *raw.iflag & ~(2 | 256 | 16 | 32 | 1024);
            raw.oflag = *raw.oflag & ~(1);
            raw.cflag = *raw.cflag | (48);
            raw.lflag = *raw.lflag & ~(8 | 2 | 32768 | 1);

            raw.cc[6] = i8(0);
            raw.cc[5] = i8(1);

            tcsetattr(0, 2, raw);

            return 0;
        };

        def disableRawMode: proc -> i32 {
            tcsetattr(0, 2, startTermios);

            return 0;
        };

        def die: proc -> i32 {
            write(1, "\e[2J", 4);
            write(1, "\e[H", 3);

            perror(s);
            exit(s);

            return 0;
        };
    };

    def Input: struct {
        def Key: struct {
            def value: prop u32;

            def BACKSPACE: const 127;

            def ARROWUP: const 1000;
            def ARROWDOWN: const 1001;
            def ARROWLEFT: const 1002;
            def ARROWRIGHT: const 1003;
            def PAGEUP: const 1004;
            def PAGEDOWN: const 1005;
            def DELETE: const 1006;

            def CTRL: inline key -> i32 {
                return key & 31;
            };
        };

        def readKey: proc -> Key {
            def c: var Key;

            c.value = 0;

            while (read(0, c.value, 1) != 1) {};

            if (*c.value == '\e') {
                def seq: var u8[3];

                if (read(0, seq[0], 1) != 1) {
                   return *c;
                };
                if (read(0, seq[1], 1) != 1) {
                   return *c;
                };

                if (*seq[0] == '[') {
                    if ((*seq[1] > ('0' - 1)) & (*seq[1] < ('9' + 1))) {
                        if (read(0, seq[2], 1) != 1) {
                            return *c;
                        };
                        if (*seq[2] == '~') {
                            if (*seq[1] == '3') { c.value = Key.DELETE; };
                            if (*seq[1] == '5') { c.value = Key.PAGEUP; };
                            if (*seq[1] == '6') { c.value = Key.PAGEDOWN; };
                        };
                    } else {
                        if (*seq[1] == 'A') { c.value = Key.ARROWUP; };
                        if (*seq[1] == 'B') { c.value = Key.ARROWDOWN; };
                        if (*seq[1] == 'C') { c.value = Key.ARROWLEFT; };
                        if (*seq[1] == 'D') { c.value = Key.ARROWRIGHT; };
                        if (*seq[1] == 'P') { c.value = Key.DELETE; };
                    };
                };
            };

            return *c;
        };

        def processKey: proc self -> i32 {
            def c: var Key;

            c = Input.readKey();

            if (*c.value == Key.CTRL('q')) {
                write(1, "\e[2J", 4);
                write(1, "\e[H", 3);

                exit(0);
            };

            def processed: var u1;
            processed = 0;

            processed = *processed | moveCursor(self, c);

            if (*c.value == Key.CTRL('s')) {
                Editor.File.save(self, *self.statusBar.fileName);

                processed = 1;
            };

            if (*c.value == Key.CTRL('f')) {
                Editor.Search.find(self);

                processed = 1;
            };

            if (*c.value == '\r') {
                insertNewline(self);

                processed = 1;
            };

            if (*c.value == Key.CTRL('E')) {
                def subKey: var Key;
                subKey.value = Key.ARROWDOWN;

                moveCursor(self, subKey);
                processed = 1;
            };

            if (*c.value == Key.CTRL('Y')) {
                def subKey: var Key;
                subKey.value = Key.ARROWUP;

                moveCursor(self, subKey);
                processed = 1;
            };

            if ((*c.value == Key.BACKSPACE) |
                (*c.value == Key.CTRL('h')) |
                (*c.value == Key.DELETE)) {
                if (*c.value == Key.DELETE) {
                    def subKey: var Key;
                    subKey.value = Key.ARROWLEFT;

                    moveCursor(self, subKey);
                };

                scroll(self);

                deleteChar(self);

                processed = 1;
            };

            processed = *processed | u1(iscntrl(*c.value));
            processed = *processed | ((*c.value) > 127 | *c.value == '\e');

            if (~(*processed)) {
                insertChar(self, c);
            };

            return 0;
        };

        def scroll: proc self -> u32 {
            self.rx = 0;
            def current: const Editor.Rows.getRow(self.row, *self.cy);
            if (current != null) {
                self.rx = Editor.Rows.cxToRx(current, *self.cx);
            };

            if (*self.cy < *self.rowoff) {
                self.rowoff = *self.cy;
            };
            if (*self.cy + 1 > *self.rowoff + *self.rows) {
                self.rowoff = *self.cy - *self.rows + 1;
            };
            if (*self.rx < *self.coloff) {
                self.coloff = *self.rx;
            };
            if (*self.rx + 1 > *self.coloff + *self.cols) {
                self.coloff = *self.rx - *self.cols + 1;
            };

            return 0;
        };

        def moveCursor: proc self key -> u1 {
            def current: const Editor.Rows.getRow(self.row, *self.cy);
            def result: var u1;

            result = 0;

            if (*key.value == Key.ARROWRIGHT) {
                result = 1;
                if (*self.cx != 0) {
                   self.cx = *self.cx - 1;
                } else {
                    if (*self.cy > 0) {
                        self.cy = *self.cy - 1;
                        self.cx = *Editor.Rows.getRow(self.row, *self.cy).size;
                    };
                };
            };
            if (*key.value == Key.ARROWLEFT) {
                result = 1;
                if (current != null) {
                    if (*self.cx < *current.size) {
                        self.cx = *self.cx + 1;
                    } else {
                        self.cy = *self.cy + 1;
                        self.cx = 0;
                    };
                };
            };
            if (*key.value == Key.ARROWUP) {
                result = 1;
                if (*self.cy != 0) {
                    self.cy = *self.cy - 1;
                };
            };
            if (*key.value == Key.ARROWDOWN) {
                result = 1;
                if (*self.cy != *self.row.numrows - 1 & *self.row.numrows != 0) {
                    self.cy = *self.cy + 1;
                };
            };

            if (*key.value == Key.PAGEUP | *key.value == Key.PAGEDOWN) {
                result = 1;
                def idx: var i16;
                def subKey: var Key;
                idx = *self.rows;

                if (*key.value == Key.PAGEUP) {
                    self.cy = *self.rowoff;
                } else {
                    self.cy = *self.rowoff + *self.rows - 1;
                    if (*self.cy > *self.row.numrows) {
                        self.cy = *self.row.numrows;
                    };
                };

                subKey.value = Key.ARROWUP;
                if (*key.value == Key.PAGEDOWN) {
                    subKey.value = Key.ARROWDOWN;
                };

                while (*idx != 0) {
                    moveCursor(self, subKey);
                    idx = *idx - 1;
                };
            };

            def current: const Editor.Rows.getRow(self.row, *self.cy);
            def len: var i32;
            len = 0;
            if (current != null) {
                len = *current.size;
            };
            if (*self.cx > *len) {
                self.cx = *len;
            };

            return *result;
        };

        def insertChar: proc self c -> i32 {
            if (*self.cy == *self.row.numrows) {
                Editor.Rows.insertRow(self.row, *self.row.numrows, "", 0);
            };

            Editor.Rows.ERow.insert(
                self.row,
                Editor.Rows.getRow(self.row, *self.cy),
                *self.cx,
                c,
                self.row.syntax
            );

            self.cx = *self.cx + 1;
            self.dirty = 1;

            return 0;
        };

        def insertNewline: proc self -> i32 {
            if (*self.cx == 0) {
                Editor.Rows.insertRow(self.row, *self.cy, "", 0);
            } else {
                def row: const Editor.Rows.getRow(self.row, *self.cy);

                Editor.Rows.insertRow(self.row, *self.cy + 1, (*row.chars + *self.cx), *row.size - *self.cx);

                def current: const Editor.Rows.getRow(self.row, *self.cy);
                current.size = *self.cx;
                (*current.chars) + (*current.size) = 0;
                Editor.Rows.ERow.update(self.row, current, self.row.syntax);
            };
            self.cy = *self.cy + 1;
            self.cx = 0;

            return 0;
        };

        def deleteChar: proc self -> i32 {
            if (*self.cy == *self.row.numrows) {
                return 0;
            };
            if (*self.cy == 0 & *self.cx == 0) {
                return 0;
            };

            def current: const Editor.Rows.getRow(self.row, *self.cy);
            if (*self.cx > 0) {
                Editor.Rows.ERow.delete(self.row, current, (*self.cx) - 1, self.row.syntax);
                self.cx = *self.cx - 1;
            } else {
                def prev: const Editor.Rows.getRow(self.row, *self.cy - 1);
                self.cx = *prev.size;
                Editor.Rows.ERow.append(self.row, prev, *current.chars, *current.size, self.row.syntax);
                Editor.Rows.deleteRow(self.row, *self.cy);
                self.cy = *self.cy - 1;
            };

            return 0;
        };
    };

    def Display: struct {
        def StatusBar: struct {
            def fileName: prop *u8;
            def msg: prop u8[80];
            def msglen: prop u32;
            def msgTime: prop TIME;

            def showMessage: proc self base msg -> i32 {
                self.msglen = snprintf(self.msg, 80, base, msg);

                self.msgTime = 0;
                self.msgTime = time(0);

                return 0;
            };

            def render: proc self ed buff -> i32 {
                Editor.Display.abuf.append(buff, "\e[7m", 4);
                def status: var u8[80];
                def rstatus: var u8[80];
                def len: var u32;
                def rlen: var u32;
                def name: var *u8;

                name = *ed.row.syntax.name;
                if (*ed.row.syntax.name == null) {
                   name = "no ft";
                };

                rlen = snprintf(rstatus, 80, "%s | %d/%d", *name, *ed.cy + 1, *ed.row.numrows);

                def dirty: var *u8;
                dirty = "";
                if (*ed.dirty) {
                   dirty = "(modified)";
                };

                if (*self.fileName == null) {
                    len = snprintf(status, 80, "%.20s - %d lines %s", "[No Name]", *ed.row.numrows, *dirty);
                } else {
                    len = snprintf(status, 80, "%.20s - %d lines %s", *self.fileName, *ed.row.numrows, *dirty);
                };

                if (*len > *ed.cols) {
                    len = *ed.cols;
                };

                Editor.Display.abuf.append(buff, status, *len);

                while (*len < *ed.cols) {
                    if (*ed.cols - *len == *rlen) {
                        Editor.Display.abuf.append(buff, rstatus, *rlen);
                        len = *len + *rlen;
                    } else {
                        Editor.Display.abuf.append(buff, " ", 1);
                        len = *len + 1;
                    };
                };

                Editor.Display.abuf.append(buff, "\e[m\r\n", 5);

                // message bar

                Editor.Display.abuf.append(buff, "\e[K", 3);
                def len: var i32;

                len = *self.msglen;

                if (*len > *ed.cols) {
                    len = *ed.cols;
                };

                if ((*len != 0) & (time(0) - (*self.msgTime) < 5)) {
                   Editor.Display.abuf.append(buff, self.msg, *len);
                };

                return 0;
            };

            def prompt: inline ed msg callback -> *u8 {
                def bufsize: var u32;
                def buflen: var u32;
                def buf: var *u8;

                bufsize = 128;
                buf = malloc(*bufsize);

                *buf = 0;
                buflen = 0;

                while (1) {
                    showMessage(ed.statusBar, msg, *buf);
                    Editor.Display.render(ed);

                    def c: var Editor.Input.Key;
                    c = Editor.Input.readKey();

                    if (*c.value == '\e') {
                        showMessage(ed.statusBar, "%s", "");
                        callback(ed, *buf, c);

                        free(*buf);
                        buf = null;
                        return *buf;
                    };

                    if (*c.value == 127) {
                       buflen = *buflen - 1;
                       (*buf + (*buflen)) = 0;
                    } else {
                        if (*c.value == '\r') {
                            if (*buflen != 0) {
                                showMessage(ed.statusBar, "%s", "");
                                callback(ed, *buf, c);

                                return *buf;
                            };
                        } else {
                            if (~iscntrl(*c.value) & *c.value < 128) {
                                if (*buflen == *bufsize - 1) {
                                    bufsize = *bufsize * 2;
                                    buf = realloc(*buf, *bufsize);
                                };
                                (*buf + (*buflen)) = u8(*c.value);
                                buflen = *buflen + 1;
                                (*buf + (*buflen)) = 0;
                            };
                        };
                    };

                    callback(ed, *buf, c);
                };

                return null;
            };
        };

        def abuf: struct {
            def b: prop *u8;
            def len: prop u32;

            def append: proc self s len -> u32 {
                self.b = realloc(*self.b, *self.len + len);

                memcpy((*self.b)[*self.len], s, len);
                self.len = *self.len + len;

                return 0;
            };

            def deinit: proc self -> u32 {
                free(*self.b);

                return 0;
            };
        };

        def drawRows: proc self buff -> u32 {
            def y: var u32;

            y = 0;

            while (*y < *self.rows) {
                def filerow: const *y + *self.rowoff;

                if (filerow > *self.row.numrows - 1) {
                    def clen: var u8;
                    clen = 0;
                    while (*clen < Editor.Settings.NUMBERLEN - 1) {
                        abuf.append(buff, " ", 1);
                        clen = *clen + 1;
                    };
                    abuf.append(buff, "~", 1);
                    abuf.append(buff, "│", 3);
                } else {
                    def numBuff: var u8[Editor.Settings.NUMBERLEN];
                    
                    def clen: var u8;
                    clen = snprintf(numBuff, Editor.Settings.NUMBERLEN, "%d", filerow);
                    def startlen: const *clen;
                    while (*clen < Editor.Settings.NUMBERLEN) {
                        abuf.append(buff, " ", 1);
                        clen = *clen + 1;
                    };

                    abuf.append(buff, numBuff, startlen);
                    abuf.append(buff, "│", 3);
                    
                    def len: var i32;
                    def current: const Editor.Rows.getRow(self.row, filerow);
                    if (*current.rsize < *self.coloff) {
                        len = 0;
                    } else {
                        len = *current.rsize - *self.coloff;
                    };

                    if (*len > *self.cols) {
                        len = *self.cols;
                    };

                    def currentColor: var i32;
                    currentColor = 0 - 1;

                    if (*len != 0) {
                        def j: var i32;
                        def c: const (*current.render) + *self.coloff;
                        def hl: const (*current.hl) + *self.coloff;

                        j = 0;
                        while (*j < *len) {
                            def char: const *(c + *j);
                            def charhl: const *(hl + *j);

                            if (iscntrl(char) != 0) {
                                def sym: var u8;
                                sym = '?';
                                if (char < 26) {
                                    sym = char + '@';
                                };
                                abuf.append(buff, "\e[7m", 4);
                                abuf.append(buff, sym, 1);
                                abuf.append(buff, "\e[m", 3);
                                if (*currentColor != 0 - 1) {
                                    def buf: var i8[16];
                                    def clen: const snprintf(buf, 16, "\e[%dm", *currentColor);
                                    abuf.append(buff, buf, clen);
                                };
                            } else {
                                if (charhl == Editor.Rows.ERow.Highlight.NORMAL) {
                                    if (*currentColor != 0 - 1) {
                                        abuf.append(buff, "\e[39m", 5);
                                        currentColor = 0 - 1;
                                    };
                                    abuf.append(buff, (c + *j), 1);
                                } else {
                                    def color: const Editor.Rows.ERow.Highlight.toColor(charhl);
                                    if (*currentColor != color) {
                                        def buf: var i8[16];
                                        def clen: const snprintf(buf, 16, "\e[%dm", color);
                                        abuf.append(buff, buf, clen);
                                        currentColor = color;
                                    };
                                    abuf.append(buff, (c + *j), 1);
                                };
                            };

                            j = *j + 1;
                        };
                        abuf.append(buff, "\e[39m", 5);
                    };
                };

                abuf.append(buff, "\e[K", 3);
                abuf.append(buff, "\r\n", 2);

                y = *y + 1;
            };

            return 0;
        };

        def render: proc self -> u32 {
            Editor.Input.scroll(self);

            def buff: var abuf;

            buff.b = null;
            buff.len = 0;

            abuf.append(buff, "\e[?25l", 6);
            abuf.append(buff, "\e[H", 3);
            Display.drawRows(self, buff);
            Display.StatusBar.render(self.statusBar, self, buff);

            def tmpBuf: var u8[32];

            snprintf(tmpBuf, 32, "\e[%d;%dH", (*self.cy - *self.rowoff) + 1,
                (*self.rx - *self.coloff) + 1 + Editor.Settings.NUMBERLEN + 1);
            abuf.append(buff, tmpBuf, strlen(tmpBuf));

            abuf.append(buff, "\e[?25h", 6);

            write(1, *buff.b, *buff.len);
            abuf.deinit(buff);

            return 0;
        };
    };

    def statusBar: prop Display.StatusBar;

    def Search: struct {
        def lastmatch: var i32;
        def direction: var i8;
        def savedhlline: var i32;
        def savedhl: var *i8;

        def findCB: proc self query key -> i32 {
            if (*savedhl != null) {
                def row: const Editor.Rows.getRow(self.row, *savedhlline);
                memcpy(*row.hl, *savedhl, *row.rsize);
                free(*savedhl);
                savedhl = null;
            };

            direction = 2;

            if (*key.value == '\r' | *key.value == '\e') {
                lastmatch = 0 - 1;
                direction = 1;
                return 0;
            };

            if (*key.value == Editor.Input.Key.ARROWDOWN) {
                direction = 1;
            };

            if (*key.value == Editor.Input.Key.ARROWUP) {
                direction = 0 - 1;
            };

            if (*direction == 2) {
                lastmatch = 0 - 1;
                direction = 1;
            };

            if (*lastmatch == 0 - 1) {
                direction = 1;
            };
            def current: var i32;
            def i: var i32;

            current = *lastmatch;
            i = 0;
            while (*i < *self.row.numrows) {
                current = *current + i32(*direction);
                if (*current == 0 - 1) {
                    current = *self.row.numrows - 1;
                } else {
                    if (*current == *self.row.numrows) {
                        current = 0;
                    };
                };

                def row: const Editor.Rows.getRow(self.row, *current);
                def match: const strstr(*row.render, query);
                if (match != null) {
                    lastmatch = *current;
                    self.cy = *current;
                    self.cx = Editor.Rows.rxToCx(row, i32(match - *row.render));
                    self.rowoff = *self.row.numrows;

                    savedhlline = *current;
                    savedhl = malloc(*row.rsize);
                    memcpy(*savedhl, *row.hl, *row.rsize);

                    memset((*row.hl + i32(match - *row.render)), Editor.Rows.ERow.Highlight.MATCH, strlen(query));
                    i = *self.row.numrows;
                };

                i = *i + 1;
            };

            return 0;
        };

        def find: proc self -> i32 {
            def query: var *u8;
            def savedCx: const *self.cx;
            def savedCy: const *self.cy;
            def savedColoff: const *self.coloff;
            def savedRowoff: const *self.rowoff;

            lastmatch = 0 - 1;
            direction = 1;
            savedhl = null;

            query = Editor.Display.StatusBar.prompt(self, "Search: %s (Use ESC/Arrows/Enter)", findCB);

            if (*query != null) {
                free(*query);
            } else {
                self.cx = savedCx;
                self.cy = savedCy;
                self.coloff = savedColoff;
                self.rowoff = savedRowoff;
            };

            return 0;
        };
    };

    def File: struct {
        def strip: proc line linelen -> i32 {
            while (*(line + (*linelen - 1)) == '\n' |
                   *(line + (*linelen - 1)) == '\r') {
                linelen = *linelen - 1;
                if (*linelen == 0) {
                    return 0;
                };
            };

            return 0;
        };

        def save: proc self afilename -> i32 {
            def filename: var *u8;

            if (afilename == null) {
                filename = Editor.Display.StatusBar.prompt(self, "Save as: %s (ESC to cancel)", defaultCallback);
                if (*filename == null) {
                    Editor.Display.StatusBar.showMessage(self.statusBar, "Save aborted %s", "");
                    return 0;
                };
            } else {
                filename = afilename;
            };

            def len: var i32;
            def buf: var *u8;

            buf = Editor.Rows.toString(self.row, len);
            def fp: var *FILE;

            fp = fopen(*filename, "wb+");
            fwrite(*buf, *len, 1, *fp);
            fclose(*fp);

            Editor.Display.StatusBar.showMessage(self.statusBar, "%d Bytes Written To Disk", *len);

            self.dirty = 0;    

            return 0;
        };

        def open: proc self filename -> i32 {
            free(*self.statusBar.fileName);
            self.statusBar.fileName = strdup(filename);

            Editor.Rows.selectSyntax(self.row, *self.statusBar.fileName);

            def fp: var *FILE;

            fp = fopen(filename, "rb");

            def line: var *u8;
            def linecap: var i32;
            def linelen: var i32;

            line = null;
            linecap = 0;
            linelen = getline(line, linecap, *fp);

            while (*linelen > 0) {
                strip(*line, linelen);

                Editor.Rows.insertRow(self.row, *self.row.numrows, *line, *linelen);

                linelen = getline(line, linecap, *fp);
            };

            free(*line);
            fclose(*fp);

            self.dirty = 0;

            return 0;
        };
    };

    def init: proc -> Editor {
        def result: var Editor;

        Terminal.getSize(result.rows, result.cols);
        result.rows = *result.rows - 2;
        result.cols = *result.cols - Editor.Settings.NUMBERLEN - 1;

        result.cx = 0;
        result.cy = 0;
        result.rx = 0;
        result.dirty = 0;
        result.statusBar.fileName = null;
        result.statusBar.msg[0] = 0;
        result.statusBar.msgTime = 0;
        result.row.numrows = 0;
        result.row.row = null;
        result.row.syntax.flags = 0;
        result.row.syntax.name = null;
        result.row.syntax.commentStart = null;
        result.rowoff = 0;
        result.coloff = 0;

        return *result;
    };

    def run: proc self -> i32 {
        def c: var u8;
        def count: var i64;

        Terminal.enableRawMode();

        while (1) {
            Display.render(self);
            Input.processKey(self);
        };

        Terminal.disableRawMode();

        return 0;
    };
};

def main: proc argc argv -> i32 {
    def ed: var Editor;

    ed = Editor.init();
    if (argc > 1) {
        Editor.File.open(ed, *(argv[1]));
    };

    Editor.Display.StatusBar.showMessage(ed.statusBar, "%s", "HELP: Ctrl-Q = quit");

    Editor.run(ed);

    return 0;
};
